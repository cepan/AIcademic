{
    "0-20": " we're now going to take up a more powerful form of indexing in fact several different improvements our first is based on the idea that if the Jaccard similarity is very high or equivalently that your card distance is very low then two strings representing sets of that jacquard distance must have a symbol in common among their prefixes whose lengths are approximately the jacquard",
    "20-40": " distance times the length of the shortest string for example if we want strings that are 90% similar that is to card distance up to 0.1 then it suffice us to look for a common symbol among the prefixes of the strings where the prefix of a string is approximately the first 10% of that string in general if j is an",
    "40-60": " upper bound on the jacquard distance we will allow then the prefix of a string of length L is the first floor of JL plus 1 positions of the string we're going to build an index in which this",
    "60-80": " string can be found using any of the symbols that appear in its prefix the formal definition we're going to use repeatedly for Strings prefix is the first floor of JL plus 1 positions that's that's that's this where J is the",
    "80-100": " upper limit we place on the jacquard distance and L is the length of the string let's start with a string of length L represented by the orange bar that suppose it has Jaccard distance j",
    "100-120": " from some other string but there's a long prefix of length e of the orange string that has no symbol in common with the purple string if the jacquard distance between the orange and purple strings is to be as low as possible the two strings must agree exactly after that prefix put",
    "120-140": " another way the orange string consists of the prefix of symbols only it has followed by the entire purple string exactly in this situation that your card distance between the strings is a / L you can check that by computing the sizes of the union which is L and the",
    "140-160": " intersection which is L minus e since these two strings are supposed to have Jaccard distance at most J we must have J greater than or equal to e / L put another way he can be as large as JL but",
    "160-180": " it can't be larger suppose we index the orange string under its first eep Loess 1 positions that's the floor of JL plus 1 positions we can take the floor since the number of positions we use has to be an integer then if the purple string is at distance at most J it will have at",
    "180-200": " least one of the symbols under which the orange string is indexed the index structure can be thought of as a collection of buckets one for each possible symbol that can appear in the strings those symbols that the members of the universal set from which all sets are drawn suppose we have a string s of",
    "200-220": " length L for each of the first floor of JL plus 1 symbols of s say a we'll put s in the bucket for a a reasonable implementation is to store the pair a s",
    "220-240": " as a key value pair where the key is the symbol a and the value is the string s we could store all these in a b-tree for example because that would make it very efficient to retrieve all the strings associated with a given symbol like a we",
    "240-260": " might store pointers to the string s rather than a copy of s itself but that's a tricky implement issue storing the strings themselves makes it more efficient to examine all the strings with a given symbol a without a lot of disk accesses but on the other hand storing pointers to a single copy of s will save space suppose",
    "260-280": " we have have set up this index and we want to find all those candidate strings that might be within Jaccard distance J from the given probe string s look at the symbols in each of the first floor of JL plus 1 positions of string s and",
    "280-300": " examine all the strings and the buckets for each of these symbols for each of these strings we need to compute the actual Jaccard distance from the probe string s and report all those within distance J let's do an example of how this indexing and search for similar strings will work let J be the upper",
    "300-320": " bound under card distance say zero point two and consider the string ABCDE F how long is its prefix well first L equals six since the string is obviously of length 6 jl is one point two that's",
    "320-340": " point 2 times 6 and jl plus 1 is 2 point 2 and the floor of 2 point 2 is of course 2 so we place ABCDEF in the",
    "340-360": " buckets for its first two symbols that is a and b how about string a cdefg here L is five so jl is 1 and the floor of j l plus 1 is again 2 so it is index in the buckets for its first two symbols a",
    "360-380": " and c what about the string BCDE well L equals 4 and J l equals 0 point 8 and the floor of 0 point 8 plus 1 is just 1",
    "380-400": " thus we index BCDE only under B now suppose we have a probe string the cdef it is also of length full length four and the floor of JL plus one is one so",
    "400-420": " we need to look only in the bucket for its first symbol which is C to explore four strings with your card distance at most 0.2 of the strings stored so far or only a CDFG this got indexed in the",
    "420-440": " bucket for C so that's the only candidate unfortunately if we do the math we find that the intersection of the sets a CDFG and the set cdef has size has size 3 that is you've got C D and F in each one",
    "440-460": " of these and the union is of size 6 it's obviously got a c d e f and g and therefore they're Jaccard distance is 0.5 which is much too high"
}