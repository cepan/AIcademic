{
    "0-20": " we're going to take up a number of interesting algorithms that compute useful properties of entire streams without storing the entire stream or most of it and here unlike our previous discussions about streams we're not just interested in querying a window of recent items but of learning something about the entire stream first we'll look at Bloom filters",
    "20-40": " this trick enables us to select only those items in a stream that are on some list of items even if the number of items on the list is so large lar that we cannot do a comparison of each stream element with each uh element of the list next we'll look at a r at random sampling of streams in a way that allows",
    "40-60": " us to be consistent about which items we select even if we see an item many times in the Stream and an interesting problem that comes up in many different applications is estimating the number of distinct items in the Stream the obvious approach where we list all the items we've ever seen and compare each new item with each",
    "60-80": " of them can require too much time and space even if we use an indexing scheme like a hash table to make the test efficient if we're willing to foro an exact answer and be content with an estimate we can do something much more space efficient finally we'll talk about the idea of moments of a",
    "80-100": " stream uh the number of distinct items terms out turns out to be a special case of zero moments but we'll give a general definition When we arrive at that topic of moment of of moments I want to explain why we need Bloom filters by using using an example application crawling the",
    "100-120": " web a web crawler uses many tasks perhaps at different processors to crawl Pages the crawler maintains a list of all the URLs it's already seen its goal is to explore the page at each of these URLs to find the additional URLs of the links on the page",
    "120-140": " each Ur each URL on the list will be assigned to some task whose job is to look at that page and report back any links it finds but we don't want to have the same URL get onto the list twice because then we would waste time crawling its page",
    "140-160": " twice so every time a URL comes back to the central controller it needs to determine whether it has seen that URL before and discard the second report if so now we could create an index say a hash table to make it efficient to look up a URL and see whether it's already among those we've seen But the web is",
    "160-180": " big and this index would not fit in main memory we could store it on disk but having to do a dis access every time we got a report of a URL would be very very timeconsuming it's possible to Shard the index across several processing nodes so each is responsible for only a small subset of the web and could therefore keep its",
    "180-200": " portion in main memory but there's a better way to get almost exact answers about whether a URL has been seen before while using much less time and space when a URL arrives in the Stream of reports from the crawling tasks instead of looking it up on disk we can pass it through a bloom filter this",
    "200-220": " filter will say either that the URL has been seen before or not if the filter says it has not been seen before the UR L will be added to the list of URLs that need to be crawled and eventually it will be assigned to some crawling task uh the bad news is that occasionally the bloom filter will give",
    "220-240": " a false positive that is it will say the URL has been seen before when in fact it is not that would be bad if the URL were the gateway to a part of the web that could only be reached through that URL however if that is is the case the part of the web we cannot reach is not very important anyway way any important",
    "240-260": " part of the web has many links from many places that's the page rank idea so missing one link will not affect much if anything the good news is that if the bloom filter says the URL has never been seen then that is true there that is there are no false",
    "260-280": " negatives okay enough of a sales pitch let's look at how a bloom filter actually works the filter itself is a large array of bids perhaps several times as many bits as there are possible elements in the Stream the bit array is manipulated through a collection of hash functions the number of hash functions could be as",
    "280-300": " little as one although several is better even a few dozen hash functions could be a good choice in some situations each hash function takes a stream element and produces a value that is one of the positions in the array it is important that the hash functions be independent it should not be possible",
    "300-320": " for to predict the result of one hash function from the result of another so we're going to start with all the bits of the array of the array equal to zero now suppose an element X arrives on the on the stream we compute the values of H ofx for each hash function H in our",
    "320-340": " collection that gives us some number of bits turn each of these bits to one if they were not already one so here's a tiny example of how a bloom Filter Works okay we're going to use an array of 11 bits we'll assume the stream consists of",
    "340-360": " integers and we'll have two hash functions the first H1 is computed from an integer X as follows uh okay we're going to write X in binary for H1 we use only the odd",
    "360-380": " positions counting them from the right that is uh we get position one is the low order bit position three is The Four's Place position five is the 16th Place 16's place and and and so on looking only at the odd position bits we get another binary",
    "380-400": " integer uh suppose that integer is I then compute I modulo 11 that is the remainder when I is divided by 11 uh that's the value of H1 of X okay H2 of X is computed in exactly the same way but from the even positions",
    "400-420": " of the binary representation of X so here's what happens when three integers arrive at the stream input initially all 11 bits of the bloom filter are zero okay the first integer is",
    "420-440": " 25 we show its value in binary with the odd numbered positions counting from the right in black and the even positions in red H1 is formed from the odd position and we see [Music]",
    "440-460": " one1 that's five in binary and five modul 11 is five uh so that's the value of H1 the even positions are one Z and that's two in binary and two modulo 11 is still two uh so that's the value of H2 so we",
    "460-480": " therefore Set uh positions two and five of the array to one uh you see the new values in Blue uh note that we're counting positions from the left end and starting at zero",
    "480-500": " the next integer is 159 and you see it written in binary here as well the odd positions in Black form 011 1 uh which is seven uh and the even positions Form 1 1",
    "500-520": " 1 uh which is 11 in decimal and 11 modulo 11 is zero so that's how we get the seven and the zero uh as the uh the two hash values uh you see position zero and",
    "520-540": " seven here uh in blue have been turned to one third to arrive is 585 the odd positions form 0 1 0",
    "540-560": " 01 uh and that's nine 9 modul 9 is 9 modul 11 is is nine uh the even positions Form 1 0 0 1 0 uh which is 18 and modul 11 that's",
    "560-580": " seven um so we set bit seven and nine to one but bit seven was already one so we make no change bit 9 is set to one as you see here we have seen how to set bits to one when we add elements to the set we're representing with the bloom filter now we need to learn how to test an element",
    "580-600": " for membership in the set let the element we want to test be y apply each of the hash functions associated with the bloom filter to Y that gives you a set of positions if all these positions are one then we say y was seen before",
    "600-620": " if y was seen before then surely all of these positions would have been set to one so we will surely say yes unfortunately there can be false positives since it could be that we never saw why but some other combination of elements managed to turn on all the bits that y would turn",
    "620-640": " on if one of the more more of the bits are zero then we'll say why was never seen that's surely correct since we know that each would have been seen set to one if y had been seen that is there are no false negatives a point worth noting is that in certain lookup can involve a single set as in our example of crawling the",
    "640-660": " web or there can be two distinct sets if the elements that we look up become part of the set that the bloom filter is to represent then when doing the lookup if we find some bits are zero we set them to one however we can also use a bloom filter to compare two sets we form the bloom filter from one set and then we test each element of the other set for",
    "660-680": " membership by doing a lookup in that case the zeros we find are left as zeros let's take up an example of how we test membership in a set we start where we left the previous example we had inserted three elements 25 159 and 585",
    "680-700": " into the set which left left the bloom filter looking like this suppose we now want to look up 118 which is this in binary uh now the odd",
    "700-720": " positions Form 1 one one0 which is 14 in decimal thus H1 of 118 is 14 modu 11 or three",
    "720-740": " the even positions give us 1 0 1 which is five in decimal and uh five modul 11 is five so H2 of 118 is five to test membership of Y in the set represented by the bloom filter we thus",
    "740-760": " look at bits three and five bit three is zero that's actually this bit bit five is a one that means 118 could not be in the set because both would have been one if so we say no and",
    "760-780": " that is the correct answer I want to do a little ugly math to explain how the bloom filter performs as a function of how big the array is how many hash functions are used and how many elements are inserted into the the set that the filter",
    "780-800": " represents first it should be evident that the false positive rate will be lower if there are a few ones in the array when we hash an element not in the underlying set the probability we find a one at that position is the fraction of ones in the array if we have K hash functions then the probability that an element not in the set will be reported",
    "800-820": " to be in the set is the fraction of ones raised to the K uh K power so what is the fraction of ones there surely cannot be more ones than there are elements inserted times the number of hash functions in practice it will be almost as large as that but collisions",
    "820-840": " where two different hashing coincide and set the same bit to one will make the actual number slightly lower at first when almost all bits are zero collisions are rare but suppose 50% of the bits are now one if we apply one of the hash functions to a new element there is a 50% chance that it will lead us to a bit that's already one and thus the number",
    "840-860": " of ones will not change when we apply this hash function to this element I like to think of picking random bits of a bloom filter to set to one as throwing darts at a collection of targets one target for each bit of the array so suppose we have D darts in our",
    "860-880": " intended application D would be the product of the number of inserted items times the number of hash functions also let there be t targets two would be the number of bits in the array what we want to know is how many targets are hit by at least one dot these are the bits that get set to one to calculate this number start with",
    "880-900": " the observation that if we throw one doart the probability that a given Target is hit is 1 overt and if we throw D DTS the probability that none Hit the Target that is the bit remains zero is 1us T well sorry 1 - 1",
    "900-920": " /t to the power D that is one minus one /t is the probability one Dart does not hit and when we we raise this the deth power we get the probability that no Dart",
    "920-940": " hits I'm going to rewrite the power d as T * d over T obviously that's just another way of writing D but the reason I want to do",
    "940-960": " that is that this part the 1 - 1/t all raised to the tth power has a well-known approximation as long as T is large it is 1 over e and E the base of natural logarithms 1 over e is is about",
    "960-980": " 0.37 in this case T is certainly large since it is the number of bits in the array thus a very good approximation to the fraction of zeros That Remain is e to the minus D over uh T I write it this",
    "980-1000": " way since 1/ e is the same as e the minus one for example let's use a bloom filter consisting of a billion bits and let's use five hash functions suppose we insert 100 million",
    "1000-1020": " elements then we do half a billion hashes so we might set to one as many as half the bits in the array in terms of darts and targets T is a billion targets and D is 500 million darts or half of t",
    "1020-1040": " using the formula we derived on the previous Slide the fraction of bits that remain zero will be e the minus D / T or E minus 12 this value is uh 607 or put another way the fraction of ones will be 393 somewhat less than",
    "1040-1060": " half uh the fact that it is less than half is explained by the existence of collisions as we apply all the hash functions to all the elements that are inserted from this inform information we can calculate the probability of a false positive for element y to be a false",
    "1060-1080": " positive all five hash functions must take it to bits that are one the probability of one hash function doing so is 393 and the probability that all five do is that raised to the fifth power or 0937 that's a little less than 1%"
}