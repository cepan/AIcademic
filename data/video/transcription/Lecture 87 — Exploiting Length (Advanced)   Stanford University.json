{
    "0-20": " but we can be even more restrictive in the set of candidates that we look for and matches to given probe string in fact much more restrictive we're going to reintroduce the idea we started with that the length of strings are an important similarity clue when the Jaccard distance must be small however",
    "20-40": " we look not at the length of the string as a whole but rather we build an index structure that takes into account both the position of a symbol in the strings prefix and the length of the portion of the string that follows it we call this length the suffix length and it changes as the position varies we're now going",
    "40-60": " to see an even more powerful scheme for indexing here we're going to index on three things the first component of the index key or bucket name is is a character at some position in the prefix of the string remember that the prefix",
    "60-80": " is the positions up to the floor of jl plus 1 that's our usual function where J is the upper bound undercard distance and L is the length of the string the second component of the key is the",
    "80-100": " number of the position in the prefix that holds the character points 1 and 2 are exactly the things we indexed using the previous method and the third component of the key is the length of the suffix of the string that is the suffix is the portion of the string to the right of the index position the addition of the suffix line because a",
    "100-120": " component of the index key gives us the additional advantage that we do not have to compare two strings if their lengths are rather different even if they have identical or almost identical prefixes let's see how we can exploit the fact that buckets contain only strings with a particular suffix length to put a stronger lower bound on the edit",
    "120-140": " distance between strings that will enable us to put a lower bound on the Jaccard distance and for some index buckets the lower bound will be so great that we know we can't find any matches in the bucket so let's consider a probe string s and suppose we think we need to compare s with another string T because the i'th position of s is the first position of s",
    "140-160": " that matches any position of T and this position is the Jade position of tea okay then we can derive a lower bound on the edit distance between S&T as follows okay first take I plus J minus 2 this is",
    "160-180": " what we use before as a lower bound on edit distance and its justification is that none of the first I minus 1 positions of s matches any of the first j minus 1 positions of T so we need to do one edit on each of those positions to convert as to t or vice versa but if",
    "180-200": " we know the suffix lengths for the two strings involved and there is an additional minimum a number of edits equal to the difference between the length of the two suffixes notice that since the index doesn't tell us exactly what symbols are in the suffix of tea we can't tell for certain where the edits are needed if we want to convert esta t by inserts and deletes but the strings",
    "200-220": " S&T may look nothing like each other and in fact many edits may be needed but we know for certain that only an edit can change to the length of the string and it changes it by one so we need at least as many edits in the suffix of s as the difference in their suffix length if we",
    "220-240": " are to turn s into T and an important point that to observe is that because the positions of S&T just before their suffixes are the same and all strings have their symbols in sorted order the only way we could change s into T by the least number of edits would be to turn the suffix of s into the suffix of tea",
    "240-260": " we also have to rethink our upper bound on the longest common subsequence of probe string s and some other string T when we take into account the suffix length so again we suppose that the first match between S&T occurs it as is",
    "260-280": " position I and it matches the j DH position of T and let's let a be the symbol in those positions then the LCS of s and T consists of the a and as long as sub sequences we can make out of there to suffixes we don't know what these suffixes are but we are sure that they cannot have more symbols in common",
    "280-300": " than the shorter of the two suffixes that's why we get 1 plus the length of the shorter as an upper bound on the length of the longest common subsequence as we did for the second variation where",
    "300-320": " we considered positions with not suffixes we can start with the fact that e / e + c is less than or equal to j again remember that e / e + c has its minimum value and e the edit distance is as low as possible and see the length of the LCS is as high as possible thus we",
    "320-340": " can set e to its lower bound and see to its upper bound and we have a lower bound on Jay but we'll make one more change writing a / e + C equal to a less than J which is of course that as E is equal to or less than J times e + C",
    "340-360": " simple arithmetic there so here's what we get here you can see the lower bound on e twice that's that's this and here's",
    "360-380": " the upper bound on see hey this is just rearranging the terms from the line above trust me it works we now build an index where the keys or triples consisting of a symbol a position",
    "380-400": " holding that symbol and a suffix length for each such triple there is a bucket and we put into the bucket a I k those strings as that have symbol a in position I and I is a position in the prefix of s and the length of the portion of the string after position I",
    "400-420": " that is the suffix is k here's a simple example the string s is a b c d e and the lower bound on the Jaccard distance is cap j is 0.2 and the prefix of s is the first two positions that's because",
    "420-440": " jl is one and the floor of jl plus one is two so for the first position of s the symbol is a the position is one and the effects of s after position one has length for that gives us this bucket and",
    "440-460": " we into that bucket of course we will put string s for the second position the symbol is B and the suffix length after position two is three that explains this bucket there are no more buckets into which we put s the lookup algorithm is",
    "460-480": " similar to what we've seen before but there are more buckets each probably contains many fewer strings and we have a stronger condition that lets us rule out a larger fraction of the buckets so suppose we're given probe string s and we want to find strings T that might be within Jaccard distance J of s we look",
    "480-500": " at certain buckets for each position of the prefix of s here's what we do for position high of s first suppose that position contains the symbol a also suppose that the suffix of s after position I has length K and for certain",
    "500-520": " values of j the position in string T and M which is the suffix length of tea after its Jade position we must look in the bucket ajm if and only if the following inequality is satisfied ok this is the inequality we derived a few",
    "520-540": " slides ago it gives us limits on j and m since I k and the Jaccard distance capital j are already known it's not all that easy to see what values of j am satisfied this inequality but there's actually a nice pattern which we will show you in a few slides",
    "540-560": " so let's see an example of look up with the string ABCDE again and again we'll have j is 0.2 okay here again is the inequality that j and m have to satisfy for each I and K and here are all the",
    "560-580": " buckets that must be searched we'll explain why in in a minute most of the action is when I equals 1 that is we are considering the poor a position one of string s this position holds a of course when i equals 1 k the suffix length of s",
    "580-600": " is for if we substitute these values for I and K as well as substitute 0.24 the Jaccard distance capital j our inequality becomes this I'm not going to do all the details here but when J",
    "600-620": " equals 1 it turns out that you need M equals three four or five in order to satisfy the inequality that is M must be pretty close to for the suffix length of s in order to make the magnitude of 4 minus M be small enough the case j",
    "620-640": " equals 1 this gives rise to these three buckets which must be searched then consider j equals two now it turns out that M must be exactly four in order",
    "640-660": " to make the magnitude of 4 minus M small enough so we get only this bucket for j equals 2 there is one more bucket be 13 this comes from the second position of string as which holds symbol B when I equals 2 we have K the suffix length",
    "660-680": " equal to 3 and here's what the inequality becomes it turns out that we have only one way to satisfy it Jay has to be 1 and M has to be three so here's",
    "680-700": " my attempt at a picture of the region in three-dimensional space where the buckets we have to search lie one dimension is I the position of the probe string s where we find the first match so we'll look at slices for each value",
    "700-720": " of I starting with i equals 1 as we have done here the position J in the other string T is the vertical dimension and the length of the suffix of T is the horizontal dimension the pairs of JM that satisfied the inequality form a",
    "720-740": " triangle with peak at k the length of the suffix for the probe string s the reason for the peak is that there is a term magnitude of M minus K that obviously grows with the difference between m and K and it doesn't matter which is larger so what we see is that",
    "740-760": " the lower the position J the bigger the difference between m and K can be eventually J grows too large and there's no value of m equal even n equals K that satisfies the inequality to be satisfied",
    "760-780": " when I equals to the values of j and the difference between m and K are more limited so the triangle is smaller notice also that the value of K has changed when we increase I the position in the probe string we decrease k the length of the suffix by the same amount",
    "780-800": " the same change happens for I equals 3 the triangle gets smaller and the value of K shifts the left so that the left sides of the triangles continue to line up eventually the triangles become a single point and then for the next higher value of I there is no triangle at all and we can stop our search I want",
    "800-820": " to leave with one observation we saw three different index schemes with one two and three dimensional indices the schemes with higher numbers of dimensions involved searching more buckets for more matches but the total",
    "820-840": " sum of the sizes of all the buckets searched or not is the same for each scheme the reason is that each string is placed in the same number of buckets regardless of the scheme that number is our old friend a floor of jl plus one the length of the prefix of the string I",
    "840-860": " claim that the expected number of strings in all the buckets that we have to search given a probe string goes down by a factor of two when we add position information because we searched a triangle instead of the containing rectangle when we add suffix length we",
    "860-880": " can get a large reduction in the number of candidates depending on the distribution of string lengths if lengths can vary widely the third scheme can eliminate almost all the false positive candidates we have to consider using the first two schemes"
}