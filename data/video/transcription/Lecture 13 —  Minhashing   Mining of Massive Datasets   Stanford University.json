{
    "0-20": " we're now going to forget whether the sets we deal with come from shingle documents or any other source and concentrate on the sets themselves we'll learn the formal definition of similarity that is commonly used for sets this notion is called jard similarity we'll then learn how to construct signatures from sets using the Min hashing technique and we'll prove the strong",
    "20-40": " relationship between the similarity of the signatures and the sets they represent let C1 and C2 be two sets their jart similarity is the size of the intersection of these two sets divided by the size of the Union we'll use sim as the function representing the jard",
    "40-60": " similarity for example these two circles represent sets there are three elements in common to both sets so the size of their intersection is three and there are eight elements in the union so the size of their Union is eight the jard similarity of these sets is the ratio of the sizes of their",
    "60-80": " intersection and and Union or 38 in this example we're going to be dealing with large collections of sets and it is useful to think of these collections as represented by a single Boolean Matrix even if the collection is not likely to be stored that way first we assume that",
    "80-100": " there is a universal set from which the elements of all sets are drawn for example if the sets come from Cas shingling documents then the universal set is the set of all possible sequences of K characters or the set of all tokens if we hash the shingles uh each element in the Universal set is represented by a row of the",
    "100-120": " Matrix and each set in the collection is represented by a column of the Matrix The Matrix has one in the row for Element e and the column for set as if and only if e is a member of s otherwise that entry is zero the column corresponding to to a",
    "120-140": " set s is the characteristic Vector of the set s the vector with ones only in the positions that correspond to the members of s we shall often talk about the jard similarity of two columns from each column form the set represented by the column the set consisting of the rows where the column has one then the deard similarity of the two columns is the deard similarity of the sets they",
    "140-160": " represent it is important to note that in typical applications The Matrix is very sparse it has many more zeros than one for example we choose k for K shingling so that documents have relatively few of the possible shingles which translates into columns having many more zeros than",
    "160-180": " ones for another example suppose The Matrix represents the books bought by Amazon customers rows are the books and Columns of the customers and customers are similar if they buy many of the same books typical customer buys only a tiny fraction of the books Amazon sells so again we would expect the Matrix to be very SP",
    "180-200": " sparse here are two columns C1 and C2 they're not sparse because it's hard to do small examples when most entries are zero however the calculation of their jard similarity is simple there are two rows where they both have one so the intersection of the sets they represent is of size",
    "200-220": " two and there are five rows where at least one of the columns has one so the size of the Union of the represented sets is five thus the jard similarity is two fths of 40% in general you can compute the similarity of two columns by counting the number of rows where both have one and dividing by the number of",
    "220-240": " rows in which one or both have one our goal is to describe how minhing of sets or Matrix columns works and to show that we can deduce the similarity of the sets or columns by looking at the signatures that result from mint hashing our first First Step will be to",
    "240-260": " observe that given two columns we can find four different kinds of row depending upon which bits are present in that Row for example a type a row has one in both columns notice that if the Matrix is sparse most of the rows will be of type D with zeros in both columns I find it useful to abuse the",
    "260-280": " notation and use a b c and d also as integers representing the number of rows of types A B C and D in The Matrix we can express the jakar similarity of two columns in terms of the counts of the row types that is the similarity of columns C1 and C2 is a ided A plus b",
    "280-300": " plus C the reason is that a is the number of rows in the intersection and a plus b plus C is the number of rows in the union we're now going to Define Min hashing each minhing hash function is associated with a permutation of the rows of The Matrix we don't physically",
    "300-320": " permute the rows that would take much too much time uh we just imagine that the rows are permuted the definition of the Minash function H associated with a permutation is that h of a column C is the number of the first row in the permuted order in which that column has one to create a signature for each of",
    "320-340": " the columns of a matrix we picked some number about 100 is often a good choice of of permutations and use their Associated Min hash function say H1 through h00 for each column the signature is the sequence of row numbers we get when we apply each of these Minash functions in turn to the column",
    "340-360": " it is important to remember that for the entire Matrix or collection of sets we select the Minash functions once and apply the same Minash functions to each of the columns we can think of the signatures as another Matrix The Columns of the signature Matrix car correspond to The",
    "360-380": " Columns of the original Matrix that is to the sets in the collection while each row in the signature Matrix is the result of applying one of the chosen Min hash functions to each of the columns let's look at a little example that should make things clearer here's an example Matrix with four columns and seven",
    "380-400": " rows okay and here's a random uh well quote random permutation of the rows uh the fifth row is the first in order that's this and the sixth row is",
    "400-420": " next and the top row is third and and so on WE construct the first component of the signature for each of the columns using this permutation we start with the row ordered first that is row",
    "420-440": " five this and this row has one in the second and fourth columns and thus we give columns 2 and four their first Min hash value it is one and that appears here okay because the first row in the",
    "440-460": " permuted order is surely the first in that order to have a one in these columns we still don't know about the twos in the first row of the signature Matrix these and this uh we'll discover those next so now we proceed to row six that's which is the second in the permuted",
    "460-480": " order and this row has ones in column one and three it happens that neither of those columns has been assigned a value yet because we haven't encountered a row in which either of those columns have W but they both get the value two because the second Row in the permuted order but not the first row in",
    "480-500": " that order has one in each of these columns in principle we have to proceed down the list of rows in the permuted order but since we've discovered a Minash value for each column there's no point in doing so here's the second quote random permutation and its resulting row of the signature Matrix in",
    "500-520": " this permutation Row three comes first it has a one in the uh second and fourth column so the second row of the signature Matrix gets one in those",
    "520-540": " columns okay now look at the second row in this order which is row two it has one in columns one in four we can't assign value two to column 4 because we already have a value value",
    "540-560": " one but we don't yet have a value for column one so we assign it uh the value two as its Minash value in the in the second Minash function uh we still don't know the value for column three because neither of the two rows examined so far have one in that column so we proceed to",
    "560-580": " the third row in the permuted order which is row four and it's has ones in columns two and four but both these columns have smaller values already so we're still not done so we move on to the fourth row uh happens to be the top row here",
    "580-600": " uh and now we find finally a one in column three so the Minh value for that column is four okay and now we're done with this Minh function",
    "600-620": " here's a third permutation and the resulting row of the signature Matrix I I'll leave it to you to study the matter and work out why the Minash values are as shown now the reason we like minhing as a way to summarize sets is expressed by the following remarkable property suppose we consider all",
    "620-640": " possible permutations of the rows and ask for what fraction of the permutations will the Minh values for the two columns C1 and C2 be the same turns out this probability is exactly the card similarity of the columns or the sets they represent okay now here's a simple proof",
    "640-660": " of this fact both the probability and the similarity are a over a plus b plus C we already know that the jard similarity of columns is given by that formula so why is the probability of the Minh values being the same also given by a over a plus b plus C imagine the rows",
    "660-680": " are permuted in a random order and imagine going down the two columns in this order let's say here's C1 here's C2 since most entries are zero we'll probably meet a lot of type D rows z0 z z",
    "680-700": " one okay and eventually we'll come to a row where at least one of the columns has a one so let's suppose here's a one now if we came first to a type a row then the Minh values for the columns would agree because we would have a one",
    "700-720": " here okay uh and they would both get this row as the as the M hash value if we come to a type B or C Row first where let's say there's a zero here then one of the columns the first one with the one gets this row as the as its Minh",
    "720-740": " value but the other column we'll have to wait until we see a one so it's definitely going to get something higher uh and they will not have the same Minh value thus the probability that two columns will have the same Min hash value is the probability that the first row that isn't of type D is a type a row that probability is the number of type A",
    "740-760": " rows divided by the number of rows of any of the types A B or C that is a / a plus b plus C armed with this observation we can sensibly Define the similarity of two signatures it is the fraction of the Minash functions for which the two",
    "760-780": " signatures have the same value it follows that the expected value of the similarity of two signatures is the jard similarity of the underlying sets moreover as we use more and more Minash functions the standard deviation of the signature similarity goes down so if we use several hundred Minash functions that is signatures of several",
    "780-800": " hundred components we get a small enough standard deviation that we can estimate the true TR card similarity of the represented sets to within a few percent that is good enough for most data mining purposes let's revisit our example of",
    "800-820": " computing signatures of length three from this Matrix let's look at some of the signature similarities and the actual column similarities remember that similarity means different things for columns and signatures for columns or sets it is the jard similarity while for signatures it is the fraction of components in which the two signatures",
    "820-840": " agree so let's look at columns one and three and their corresponding signatures here the jakar similarity of the two columns is 34s uh notice that there are",
    "840-860": " four rows where at least one of these two columns is one that is here here here and here and in all but this",
    "860-880": " one uh they both have one thus the size of the intersection is three and the size of the Union is four now look at signature one and three they agree for the first and third Minash functions but they disagree on the the second uh thus the sign signature",
    "880-900": " similarity is 2/3 now 2/3 is pretty close to 3/4 but there is some discrepancy uh as we uh note uh here uh if we look at columns 2 and four",
    "900-920": " uh we again find the jacard similarity is 3/4 but here the similarity of the signatures is one they are in fact identical in all three uh components another interesting example",
    "920-940": " is columns 1 and two uh these columns have an empty intersection uh so they jard similarity is zero it turns out that when the jard similarity is zero it is impossible for any mid hash function to return the same value for these two columns uh as we see again in the white uh",
    "940-960": " table uh thus the similarity of these signatures is zero as as it as it must be remember that we have defined minhing as if we actually permuted the rows but it is not really feasible to do so so let's consider data of modest size where",
    "960-980": " there are a billion rows first of all takes a lot of time to pick a random permutation of a billion things you essentially have to generate a build a billion random integers and do something with each and representing a random permutation of a billion items takes at least 4 gigabytes of space if we have say 100 random permutations then that's",
    "980-1000": " 4/10 of a terabyte just to store the permutation okay and if you try to access the rows of the Matrix according to the order of one of these permutations then you'll have to do many disk accesses to get each row and that's incredibly time",
    "1000-1020": " consuming uh here's how we simulate permutations without without actually permuting rows for each Minh function we pick a normal sort of hash function that hashes integers uh to some number of buckets uh we pretend that the position of row R in the permutation is a h of R where H is the hash function uh so for",
    "1020-1040": " each column we look for that row R in which the column has a one and for which h of R is the smallest more specifically let's pick some number of ordinary hash functions say 100 hash functions one for each Min hash function we want to simulate okay for each column C we keep",
    "1040-1060": " a slot for each of the hash functions called the slot for column C and the I hash function m of I and C if we want 100 Minash functions uh then the number of slots is 100 times the number of columns our goal is that eventually M of",
    "1060-1080": " I and c will become the smallest value of H sub I of R for which column C has a one in row r that is we suppose that the I Minash function orders rows by the value to which H subi sends each row notice that this ordering is not exact l a permutation it's entirely",
    "1080-1100": " possible that h of H subi Maps two or more rows to the same value but if we make the number of buckets into which h of I hash is very large larger than the number of rows then the probability of a collision at the smallest value is very small and we can ignore the probability of a",
    "1100-1120": " collision so here's the algorithm in a nutshell the outer loop is on the rows okay for each row R the first thing we do is compute each of the perhaps 100 hash values h subi of R that's",
    "1120-1140": " this then we Loop over all the column C and if column C does not have a one in row R then we do nothing for R and C okay but now suppose Matrix M has one in row R and column C uh then we're",
    "1140-1160": " going to Loop over the index I uh for all the hash functions and for each of these perhaps 100 values of I we check whether H sub I of R is smaller than the smallest value currently in the",
    "1160-1180": " slot for the hash function uh uh for uh hash function I in column C uh if that is the case then we replace that slot by uh H sub I of R we take uh M of I and C to be Infinity initially so the first row in which we",
    "1180-1200": " we find that has a one in column C surely is placed in that slot uh also note that it is important we compute H sub of R only once for each hash function in each row outside the loop over the columns that's that was that was this",
    "1200-1220": " so let's do a little example uh our Matrix has only two columns and five rows that's that's this um we're going to use two hash functions that is we compute signatures of length two the two hash function functions that",
    "1220-1240": " we use are are shown here uh each Maps integers to five buckets the the first which we call H of x uh Maps any integer X to x modul 5 uh that is the remainder when X is divided by five the second G of x uh",
    "1240-1260": " computes 2x + one and again takes that module 5 takes the remainder of 2x + 1 mod 5 okay we're ready to compute the two components of the signatures for each of these columns remember that initially we assume all slots are Infinity uh Begin by looking at the first",
    "1260-1280": " row and we find H of one is 1 and G of one is three uh modulo take take them all modulo five so three modul 5 is in fact three uh now Row one has one in the First Column but zero in in the second",
    "1280-1300": " uh column uh therefore the second signature is not changed and both its components remain in Infinity uh but the first signature is change to the values of H of one and G of one that is uh one and three okay now consider the second row h",
    "1300-1320": " of 2 is two and G of 2 is 5 modul 5 or zero since column one has zero in the second row uh we do not change its",
    "1320-1340": " signature but column two has one in row two so we replace the infinite values in its signature by two and zero next the third row H of3 is three and g of three is 7even modulo 5 which is two uh there is one in row three of",
    "1340-1360": " both columns so both signatures are candidates for being lowered however h of three is three and the first component of both signatures are already lower one and two respectively so we do not change either first component now G of3 is two so we",
    "1360-1380": " might change either second component uh for the first signature the current value is three uh so we lower it to two but for the second signature signature the current value is already zero so uh we leave it at",
    "1380-1400": " zero h of four is four and G of four is 9 modul 5 which is four and since four is larger than any of the current slots for the First Column no changes are",
    "1400-1420": " made finally h of five is five modu of 5 or zero and G of five is 11 modul 5 or 1 only the second column has a one in row five so we can only change its signature",
    "1420-1440": " since H to five equals Zer and the old value of the slot for H is two we change it to zero but the slot for G already has zero which is lower than G of five which is one so no changes made",
    "1440-1460": " there thus the final signatures are one two for the First Column and 0 0 for the second column incidentally notice that the two signatures disagree for both components so they estimate the jard similarity of",
    "1460-1480": " the columns to be zero and that's off by a little since as you can see the true jacard similarity of the columns is one5 One Last Detail is worth mentioning the algorithm we we describe assumes we can visit the Matrix row by row but often the data is available by columns and not by",
    "1480-1500": " rows for instance if we have a file of documents it's natural to process each document once Computing its shingles that in effect gives us one column of the Matrix if so we need to do one preliminary step sort the data so it is organized by row that's not hard start with a list of",
    "1500-1520": " row column pairs where the ones are initially sorted by column and sort these pairs by row"
}